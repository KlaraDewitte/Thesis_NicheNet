---
title: "Bioxrvir_with_ANANSE_48"
author: "Klara Dewitte"
date: "2022-11-28"
output: html_document
---
##Load packages, get RNA-seq data and get DE genes
Load the packages.
```{r libraries}
library(limma) 
library(edgeR)
library(stringr)
library(tidyverse)
library(dplyr)
library(nichenetr)
library(biomaRt)
library(data.table)
library(stringr)
library(synapser) 
```

Get the RNAsesq data from Synapsr.
```{r loop}
# login of synapsr
synLogin('KlaraDewitte','Thesis2022') 
 
# Obtain a pointer and download the RNA-seq level 1 data
syn18508389 <- synGet(entity = 'syn18508389') 
filepath_RNA <- syn18508389$path
rawdata <- read.csv(filepath_RNA, row.names = 1)

# Obtain pointer and download metadata
ssyn15574180 <- synGet(entity = 'syn15574180') 
filepath_metadata <- ssyn15574180$path
metadata <- read.csv(filepath_metadata)

# Obtain subset of metadata and RNA-seq data for 24h and 48h
values <- stringr::str_split(metadata$specimenName, "_") %>% 
                  do.call(rbind, .) 

id_24 <- metadata[which(values[,2] == 24 & metadata$RNAseq_QCpass == TRUE) ,]$specimenID 
id_48 <- metadata[which(values[,2] == 48 & metadata$RNAseq_QCpass == TRUE),]$specimenID

rawdata_subset_24 <- rawdata[,which(colnames(rawdata) %in% id_24)]
rawdata_subset_48 <- rawdata[,which(colnames(rawdata) %in% id_48)]

metadata_subset_24 <- metadata[which(metadata$specimenID %in% id_24),]
metadata_subset_48 <- metadata[which(metadata$specimenID %in% id_48),]

# Get unique values of each cytokin, timepoint and replicate
unique_values <- values %>%
                  apply(2, unique) %>%
                  setNames(c("cytokine", "timepoint", "collection", "replicate"))

ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# Get treatment groups for 48h
Treat <- sapply(str_split(metadata_subset_48$specimenName, "_"), function(k) k[1])
Treat <- Treat %>% factor %>% relevel(ref = "PBS")
    
# Create design matrix
design <- model.matrix(~ Treat)
rownames(design) <- metadata_subset_48$specimenName
    
# Preprocess counts, estimate dispersion
y <- DGEList(counts = rawdata_subset_48, group = Treat)
y <- calcNormFactors(y)
y <- estimateDisp(y, design, robust = TRUE)
    
# Fit the model
fit <- glmQLFit(y, design)
    
# Perform test for each cytokine against PBS
res <- data.table()
for (treat in colnames(design)[-1]){
  qlf <- glmQLFTest(fit, coef = treat)
  DE_genes_table <- data.frame(topTags(qlf, sort.by = "PValue", n = Inf),  coef = substring(treat, 6))
  DE_genes_table$Gene <- rownames(DE_genes_table)
  res <- rbind(res, DE_genes_table)
}
   
# Add gene names
IDtoSymbol_matrix <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), filters = "ensembl_gene_id", values = unique(res$Gene), mart = ensembl)
top_table <- merge(res, IDtoSymbol_matrix, by.x = 'Gene', by.y = 'ensembl_gene_id', all.x = TRUE)
    
# Omit all the genes with NA or an empty name
top_na <- na.omit(top_table) 
top_na <- top_na[!(top_na$external_gene_name==""),]
    
# Select DE genes and make expression_settings_validation for evaluation NicheNet
total <- c()
total_names_DE <- c()
DEgenes <- list
expression_settings_validation_DE <- list()
DE_info <- list()
designs <- list()
table1 <- list()
designs <- list()

for(treatx in unique_values$cytokine){
  if (treatx != "PBS" & treatx != "ctrl"){
    top_na_subset <- top_na[top_na$coef == treatx,]
    DE <- which(top_na_subset$FDR < 0.05 & abs(top_na_subset$logFC) > 2)
    DEgenes <- top_na_subset[DE,]
        
    table2 <- list()
    table2$DEgenes <- DEgenes
    DE_info <- append(DE_info, list(DEgenes))
    
    treatx <- gsub("TGFB", "TGFB1", treatx)
    treatx <- gsub("IFNg", "IFNG", treatx)
        
    print(treatx)
    print(paste0("number of DE genes ", length(DE)))
    
    if (length(DE) > 0){
      total_names_DE <- append(total_names_DE, treatx)
      subsets <- subset(top_na_subset, select = c(logFC, FDR, external_gene_name))
      names(subsets) <- c('lfc', 'qval', 'gene')
      rownames(subsets) <- 1:nrow(subsets)
      table3 <- list()
      table3$diffexp <- as.data.frame(subsets)
      table3$from <- c(treatx)
      table3$name <- c(treatx)
          
      expression_settings_validation_DE <- append(expression_settings_validation_DE, list(table3))
    }
    total <- (append(total, treatx))
    names(expression_settings_validation_DE) <- total_names_DE
    table1$expression_settings_validation_DE <- expression_settings_validation_DE 
        
   }
}
names(DE_info) <- total
table1$DE_info <- DE_info
designs <- append(designs, list(table1))

```

##Construction of ligand_target_matrix
In GRN.R are the weighted networks and individual ligand-target-matrices constructed.
```{r ligand-target-matrix construction}
# The complete networks can be downloaded from Zenodo
lr_network <- readRDS(url("https://zenodo.org/record/5884439/files/lr_network_human_21122021.rds"))
sig_network <- readRDS(url("https://zenodo.org/record/5884439/files/signaling_network_human_21122021.rds"))
gr_network <- readRDS(url("https://zenodo.org/record/5884439/files/gr_network_human_21122021.rds"))
gr_network_LINCS <- read.table("Ananse_networks/LINCS_MCF10A_TGFB_48_grn.txt", header = TRUE, sep = ";")
test <- readRDS(unzip(url("https://zenodo.org/record/7418451/files/LINCS_MCF10A_EGF_48.network.txt.gz")))

temp <- tempfile()
download.file("http://www.newcl.org/data/zipfiles/a1.zip",temp)
data <- read.table(unz(temp, "a1.dat"))
unlink(temp)

#add your new source to the weighted networks in NicheNet (weight??)
new_network_weights_df <- tibble(source = "LINCS_MCF10A_TGFB_48", weight = 1)
new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network <- gr_network %>% bind_rows(gr_network_LINCS)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks = construct_weighted_networks(lr_network = lr_network, sig_network = sig_network, gr_network = new_gr_network, source_weights_df = new_source_weights_df)

ligands <- list("EGF", "HGF", "OSM", "IFNG", "TGFB1", "BMP2")

ligand_target_matrix <- construct_ligand_target_matrix(weighted_networks = weighted_networks, ligands = ligands)
```
## Evaluation NicheNet
# model evaluation
You can also embed plots, for example:

```{r model evaluation, error=TRUE, warning=TRUE}

    for (i in 1:length(designs)){
    expression_settings_validation_DE <- designs[[i]]$expression_settings_validation_DE
    if(length(expression_settings_validation_DE) > 0){
      #print(head(expression_settings_validation_DE))
      # Step 1: convert expression datasets to the required format to perform target gene prediction
      settings = expression_settings_validation_DE %>% lapply(convert_expression_settings_evaluation)
      settings = settings %>% discard(~length(.$from) > 1)
      designs[[i]]$settings <- settings
      #print(names(which(settings$response)))
      
      # Step 2: calculate the target gene prediction performances
      performances = settings %>% lapply(evaluate_target_prediction, ligand_target_matrix) %>% bind_rows() 
      designs[[i]]$performances <- as.data.frame(performances)
      
      # Visualize some classification evaluation metrics showing the target gene prediction performance
      performances = performances %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval ,-sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)
      scorelabels = c(auroc="AUROC", aupr_corrected="AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)",pearson = "Pearson correlation", spearman = "Spearman's rank correlation",mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")
      scorerandom = c(auroc=0.5, aupr_corrected=0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0,mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")
      
      print(performances %>%
              mutate(model = "NicheNet") %>%
              ggplot() +
              geom_violin(aes(model, scorevalue, group=model, fill = model)) +
              geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
              scale_y_continuous("Score target prediction") +
              facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
              geom_hline(aes(yintercept =scorevalue), data=scorerandom, linetype = 2, color = "red") +
              theme_bw()
      )
    }
  }
  
  for (i in 1:length(designs)){
  settings <- designs[[i]]$settings
  if(length(settings) > 0){
    # convert expression datasets to correct format for ligand activity prediction
    all_ligands = settings %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
    settings_ligand_prediction = settings %>% convert_settings_ligand_prediction(all_ligands = all_ligands, validation = TRUE)
    
    # infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific dataset (and we do this for all datasets).
    ligand_importances = settings_ligand_prediction %>% lapply(get_single_ligand_importances, ligand_target_matrix) %>% bind_rows()
    ligand_importances <- do.call(data.frame,lapply(ligand_importances, function(value) replace(value, is.infinite(value), 100000)))
    
    # Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)
    evaluation_ligand_prediction = ligand_importances$setting %>% unique() %>% lapply(function(x){x}) %>% 
      lapply(wrapper_evaluate_single_importances_ligand_prediction, ligand_importances) %>%
      bind_rows() %>% inner_join(ligand_importances %>% distinct(setting, ligand))
    
    # Visualize some classification evaluation metrics showing the ligand activity prediction performance
    evaluation_ligand_prediction = evaluation_ligand_prediction %>% dplyr::select(-aupr, -sensitivity_roc, -specificity_roc, -pearson, -spearman, -mean_rank_GST_log_pval) %>% gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
    scorelabels = c(auroc="AUROC", aupr_corrected="AUPR (corrected)")
    scorerandom = c(auroc=0.5, aupr_corrected=0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")
    
    print(evaluation_ligand_prediction %>%
      filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson", "spearman")) %>%
      ggplot() +
      geom_violin(aes(importance_measure, scorevalue, group=importance_measure, fill = importance_measure)) +
      geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure),width = 0.1) +
      scale_y_continuous("Evaluation ligand activity prediction") +
      scale_x_discrete("Ligand activity measure") +
      facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
      geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90)))
  }
}

```

