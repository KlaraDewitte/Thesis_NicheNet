---
title: "Biorxiv_data_24"
author: "Klara Dewitte"
output: html_document
---

```{r libraries}
library(limma) 
library(edgeR)
library(stringr)
library(tidyverse)
library(dplyr)
library(nichenetr)
library(biomaRt)
library(data.table)
library(stringr)
library(synapser) 
```


```{r loop}
synLogin('KlaraDewitte','Thesis2022') 
 
# Obtain a pointer and download the RNA-seq level 1 data
syn18508389 <- synGet(entity = 'syn18508389') 
filepath_RNA <- syn18508389$path
rawdata <- read.csv(filepath_RNA, row.names = 1)

# Obtain pointer and download metadata
ssyn15574180 <- synGet(entity='syn15574180') 
filepath_metadata <- ssyn15574180$path
metadata <- read.csv(filepath_metadata)

# Obtain subset of metadata and RNA-seq data for 24h and 48h
values <- stringr::str_split(metadata$specimenName, "_") %>% 
                  do.call(rbind, .) 

id_24 <- metadata[which(values[,2] == 24 & metadata$RNAseq_QCpass == TRUE) ,]$specimenID 
id_48 <- metadata[which(values[,2] == 48 & metadata$RNAseq_QCpass == TRUE),]$specimenID

rawdata_subset_24 <- rawdata[,which(colnames(rawdata) %in% id_24)]
rawdata_subset_48 <- rawdata[,which(colnames(rawdata) %in% id_48)]

metadata_subset_24 <- metadata[which(metadata$specimenID %in% id_24),]
metadata_subset_48 <- metadata[which(metadata$specimenID %in% id_48),]

# Get unique values of each cytokin, timepoint and replicate
unique_values <- values %>%
                  apply(2, unique) %>%
                  setNames(c("cytokine", "timepoint", "collection", "replicate"))

ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", mirror = "useast")

# Get treatment groups
Treat <- sapply(str_split(metadata_subset_24$specimenName, "_"), function(k) k[1])
Treat <- Treat %>% factor %>% relevel(ref = "PBS")
    
# Create design matrix
design <- model.matrix(~ Treat)
rownames(design) <- metadata_subset_24$specimenName
    
# Preprocess counts, estimate dispersion
y <- DGEList(counts = rawdata_subset_24, group = Treat)
y <- calcNormFactors(y)
y <- estimateDisp(y, design, robust = TRUE)
    
# Fit the model
fit <- glmQLFit(y, design)
    
# Perform test for each cytokine against PBS
res <- data.table()
for (treat in colnames(design)[-1]){
  qlf <- glmQLFTest(fit, coef = treat)
  DE_genes_table <- data.frame(topTags(qlf, sort.by = "PValue", n = Inf),  coef = substring(treat, 6))
  DE_genes_table$Gene <- rownames(DE_genes_table)
  res <- rbind(res, DE_genes_table)
}
   
# Add gene names
IDtoSymbol_matrix <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"), filters = "ensembl_gene_id", values = unique(res$Gene), mart = ensembl)
top_table <- merge(res, IDtoSymbol_matrix, by.x = 'Gene', by.y = 'ensembl_gene_id', all.x = TRUE)
    
# Omit all the genes with NA or an empty name
top_na <- na.omit(top_table) 
top_na <- top_na[!(top_na$external_gene_name==""),]
    
# Select DE genes and make expression_settings_validation for evaluation NicheNet
total <- c()
total_names_DE <- c()
DEgenes <- list
expression_settings_validation_DE <- list()
DE_info <- list()
designs <- list()
table1 <- list()
designs <- list()

for(treatx in unique_values$cytokine){
  if (treatx != "PBS" & treatx != "ctrl"){
    total <- (append(total, treatx))
    top_na_subset <- top_na[top_na$coef == treatx,]
    DE <- which(top_na_subset$FDR < 0.05 & abs(top_na_subset$logFC) > 2)
    DEgenes <- top_na_subset[DE,]
    writexl::write_xlsx(DEgenes, path = paste0("DEgenes/", treatx, "_DEgenes_24.xlsx"))
        
    table2 <- list()
    table2$DEgenes <- DEgenes
    DE_info <- append(DE_info, list(DEgenes))
        
    print(treatx)
    print(paste0("number of DE genes ", length(DE)))
        
    if (treatx == 'TGFB'){
      treatx <- 'TGFB1'
    }
    if (length(DE) > 0){
      total_names_DE <- append(total_names_DE, treatx)
      subsets <- subset(top_na_subset, select = c(logFC, FDR, external_gene_name))
      names(subsets) <- c('lfc', 'qval', 'gene')
      rownames(subsets) <- 1:nrow(subsets)
      table3 <- list()
      table3$diffexp <- as.data.frame(subsets)
      table3$from <- c(treatx)
      table3$name <- c(treatx)
          
      expression_settings_validation_DE <- append(expression_settings_validation_DE, list(table3))
    }
    names(expression_settings_validation_DE) <- total_names_DE
    table1$expression_settings_validation_DE <- expression_settings_validation_DE 
        
   }
}
names(DE_info) <- total
table1$DE_info <- DE_info
designs <- append(designs, list(table1))

```
## Evaluation NicheNet
# Transcriptional response prediction evaluation
```{r model evaluation, echo=TRUE, error=TRUE, warning=TRUE}
file_ligand = "Datasets_vignettes/ligand_target_matrix_nsga2r_final.rds"
ligand_target_matrix = readRDS(file = file_ligand)

#all ligands
expression_settings_validation_DE <- designs[[1]]$expression_settings_validation_DE
if(length(expression_settings_validation_DE) > 0){
  #print(head(expression_settings_validation_DE))
  # Step 1: convert expression datasets to the required format to perform target gene prediction
  settings_all = expression_settings_validation_DE %>% lapply(convert_expression_settings_evaluation)
  settings_all = settings_all %>% discard(~length(.$from) > 1)
  designs[[1]]$settings_all <- settings_all
  #print(names(which(settings$response)))
    
  # Step 2: calculate the target gene prediction performances
  performances_all = settings_all %>% lapply(evaluate_target_prediction, ligand_target_matrix) %>% bind_rows() 
  designs[[1]]$performances_all <- as.data.frame(performances_all)
  writexl::write_xlsx(performances_all, path = "NicheNet_output/performances_all_24.xlsx")
    
  # Visualize some classification evaluation metrics showing the target gene prediction performance
  performances_all = performances_all %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval ,-sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)
  scorelabels = c(auroc = "AUROC", aupr_corrected = "AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)", 
                  pearson = "Pearson correlation", spearman = "Spearman's rank correlation", 
                  mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")
  scorerandom = c(auroc = 0.5, aupr_corrected = 0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0,mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue = .) %>% rownames_to_column("scorename")
    
  print(performances_all %>%
          mutate(model = "NicheNet") %>%
          ggplot() +
          geom_violin(aes(model, scorevalue, group=model, fill = model)) +
          geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
          scale_y_continuous("Score target prediction") +
          facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
          geom_hline(aes(yintercept =scorevalue), data=scorerandom, linetype = 2, color = "red") +
          theme_bw()
  )
}

#one ligand (EGF, HGF, OSM)
expression_settings_validation_DE_one <- list(designs[[1]]$expression_settings_validation_DE$EGF,
                                designs[[1]]$expression_settings_validation_DE$HGF,
                                designs[[1]]$expression_settings_validation_DE$OSM)

names_one <- c("EGF", "HGF", "OSM")
names(expression_settings_validation_DE_one) <- names_one

if(length(expression_settings_validation_DE_one) > 0){
  # Step 1: convert expression datasets to the required format to perform target gene prediction
  settings_one = expression_settings_validation_DE_one %>% lapply(convert_expression_settings_evaluation)
  settings_one = settings_one %>% discard(~length(.$from) > 1)
  designs[[1]]$settings_one <- settings_one
  #print(names(which(settings$response)))
  
  # Step 2: calculate the target gene prediction performances
  performances_one = settings_one %>% lapply(evaluate_target_prediction, ligand_target_matrix) %>% bind_rows() 
  designs[[1]]$performances_one <- as.data.frame(performances_one)
  writexl::write_xlsx(performances_one, path = "NicheNet_output/performances_one_24.xlsx")
    
  # Visualize some classification evaluation metrics showing the target gene prediction performance
  performances_one = performances_one %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval , -sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)
  scorelabels = c(auroc = "AUROC", aupr_corrected = "AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)", 
                  pearson = "Pearson correlation", spearman = "Spearman's rank correlation", 
                  mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")
  scorerandom = c(auroc = 0.5, aupr_corrected = 0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0, mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue = .) %>% rownames_to_column("scorename")
    
  print(performances_one %>%
          mutate(model = "NicheNet") %>%
          ggplot() +
          geom_violin(aes(model, scorevalue, group = model, fill = model)) +
          geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
          scale_y_continuous("Score target prediction") +
          facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
          geom_hline(aes(yintercept =scorevalue), data=scorerandom, linetype = 2, color = "red") +
          theme_bw()
  )
}

```

# ligand activity prediction evaluation

```{r ligand activity prediction evaluation, echo=TRUE, error=TRUE}
#all ligands added
settings_all <- designs[[1]]$settings_all

if(length(settings_all) > 0){
   # convert expression datasets to correct format for ligand activity prediction
   all_ligands = settings_all %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
   settings_ligand_prediction_all = settings_all %>% convert_settings_ligand_prediction(all_ligands = all_ligands, validation = TRUE)
    
  # infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific dataset (and we do this for all datasets).
  ligand_importances_all = settings_ligand_prediction_all %>% lapply(get_single_ligand_importances, ligand_target_matrix) %>% bind_rows()
  ligand_importances_all <- do.call(data.frame, lapply(ligand_importances_all, function(value) replace(value, is.infinite(value), 100000)))
  
    # Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)
  evaluation_ligand_prediction_all = ligand_importances_all$setting %>% unique() %>% lapply(function(x){x}) %>% 
      lapply(wrapper_evaluate_single_importances_ligand_prediction, ligand_importances_all) %>%
      bind_rows() %>% inner_join(ligand_importances_all %>% distinct(setting, ligand))
   writexl::write_xlsx(evaluation_ligand_prediction_all, path = "NicheNet_output/ligand_all_24.xlsx")
    
   # Visualize some classification evaluation metrics showing the ligand activity prediction performance
   evaluation_ligand_prediction_all = evaluation_ligand_prediction_all %>% dplyr::select(-aupr, -sensitivity_roc, -specificity_roc, -pearson, -spearman, -mean_rank_GST_log_pval) %>% gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
    scorelabels = c(auroc = "AUROC", aupr_corrected = "AUPR (corrected)")
    scorerandom = c(auroc = 0.5, aupr_corrected = 0) %>% data.frame(scorevalue = .) %>% rownames_to_column("scorename")
    
  print(evaluation_ligand_prediction_all %>%
     filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson",
                                      "spearman")) %>%
     ggplot() +
     geom_violin(aes(importance_measure, scorevalue, group=importance_measure, fill = importance_measure)) +
     geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure),width = 0.1) +
     scale_y_continuous("Evaluation ligand activity prediction") +
     scale_x_discrete("Ligand activity measure") +
     facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
     geom_hline(aes(yintercept=scorevalue), data = scorerandom, linetype = 2, color = "red") +
     theme_bw() +
     theme(axis.text.x = element_text(angle = 90)))
}

#one ligand
designs[[1]]$settings_one <- settings_one
names(settings_one) <- names_one
    
if(length(settings_one) > 0){
  # convert expression datasets to correct format for ligand activity prediction
  all_ligands = settings_one %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
  settings_ligand_prediction_one = settings_one %>% convert_settings_ligand_prediction(all_ligands = all_ligands, validation = TRUE)
    
   # infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific dataset (and we do this for all datasets).
   ligand_importances_one = settings_ligand_prediction_one %>% lapply(get_single_ligand_importances, ligand_target_matrix) %>% bind_rows()
   ligand_importances_one <- do.call(data.frame, lapply(ligand_importances_one, function(value) replace(value, is.infinite(value), 100000)))
    
    # Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)
   evaluation_ligand_prediction_one = ligand_importances_one$setting %>% unique() %>% lapply(function(x){x}) %>% 
    lapply(wrapper_evaluate_single_importances_ligand_prediction, ligand_importances_one) %>%
    bind_rows() %>% inner_join(ligand_importances_one %>% distinct(setting, ligand))
   
   writexl::write_xlsx(evaluation_ligand_prediction_one, path = "NicheNet_output/ligand_one_24.xlsx")
    
  # Visualize some classification evaluation metrics showing the ligand activity prediction performance
  evaluation_ligand_prediction_one = evaluation_ligand_prediction_one %>% dplyr::select(-aupr, -sensitivity_roc, -specificity_roc,
                                                                                        -pearson, -spearman,
                                                                                        -mean_rank_GST_log_pval) %>% 
    gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
  scorelabels = c(auroc = "AUROC", aupr_corrected = "AUPR (corrected)")
  scorerandom = c(auroc = 0.5, aupr_corrected = 0) %>% data.frame(scorevalue = .) %>% rownames_to_column("scorename")
    
  print(evaluation_ligand_prediction_one %>%
     filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson",
                                      "spearman")) %>%
    ggplot() +
    geom_violin(aes(importance_measure, scorevalue, group = importance_measure, fill = importance_measure)) +
    geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure), width = 0.1) +
    scale_y_continuous("Evaluation ligand activity prediction") +
    scale_x_discrete("Ligand activity measure") +
    facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
    geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)))
  }

```