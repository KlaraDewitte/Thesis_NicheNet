---
title: "Epigenetic NicheNet"
author: "Klara Dewitte"
date: "2022-11-28"
output: html_document
---
##Load packages, get RNA-seq data and get DE genes
Load the packages.
```{r libraries}
library(limma) 
library(edgeR)
library(stringr)
library(tidyverse)
library(dplyr)
library(nichenetr)
library(biomaRt)
library(data.table)
library(stringr)
library(synapser) 
library(knitr)
library(ggstatsplot)
library(cowplot)
library(annotables)
memory.limit(size = 3000000)
knitr::opts_chunk$set(error = TRUE)
```

```{r NicheNet default networks}
# NicheNet default networks
lr_network <- readRDS(url("https://zenodo.org/record/7074291/files/lr_network_human_21122021.rds"))
sig_network <- readRDS(url("https://zenodo.org/record/7074291/files/signaling_network_human_21122021.rds"))
gr_network <- readRDS(url("https://zenodo.org/record/7074291/files/gr_network_human_21122021.rds"))
ligand_target_matrix <- readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final.rds"))
```

## Check 1. NicheNet genes and Ananse genes
First, we will load in an appropriate GRN network by Ananse and NicheNet v2's prior model to verify that there is no issue there with the correspondence of the gene names.

```{r Checking gene correspondence between NicheNet prior model and Ananse output}
ligand_target_matrix[1:5,1:5] # target genes in rows, ligands in columns
targets.NN <- unique(rownames(ligand_target_matrix))
length(targets.NN) #33354
head(targets.NN,10)

# loading in some GRN network 
# rp_LINCS_MCF10A_EGF_24_grn.txt
test.GRN <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_EGF_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")
targets.GRN <- unique(test.GRN$to) # 36115 target genes
length(targets.GRN) #32495
head(targets.GRN)

# checking the overlap
length(intersect(targets.NN,targets.GRN)) #3453
head(setdiff(targets.NN,targets.GRN),10)
head(setdiff(targets.GRN,targets.NN),10)
```
We see that the GRNs provided by Ananse have human genes and the overlap is quite high between both with `length(intersect(test.GRN$to,rownames(ligand_target_matrix)))` genes. Still, a lot of target genes from the ANANSE network are missing, but maybe no prior knowledge on them?

## Check 2: RNA gene annotations

First load in the data, there seem to be counts, gene annotations and sample meta data. We can take a closer look at the annotation of the genes. So the gene annotations seem to match and we could run an analysis that we want. Note that no conversions are needed.

```{r loop, echo=TRUE}
# login of synapsr
synLogin('KlaraDewitte','Thesis2022') 

# Obtain a pointer and download the RNA-seq level 1 data
syn18508389 <- synGet(entity = 'syn18508389') 
filepath_RNA <- syn18508389$path
rawdata <- read.csv(filepath_RNA, row.names = 1)

# Obtain pointer and download metadata
ssyn15574180 <- synGet(entity = 'syn15574180') 
filepath_metadata <- ssyn15574180$path
metadata <- read.csv(filepath_metadata)

# Obtain pointer and download RNA gene annotations
syn18779231 <- synGet(entity = 'syn18779231') 
filepath_annotations <- syn18779231$path
rna.annot <- read.csv(filepath_annotations)
targets.RNA <- unique(rna.annot$hgnc_symbol)

# how many unique human genes do we have?
length(targets.RNA) #37263

# checking the overlap
length(intersect(targets.NN, targets.RNA)) # also reasonable 27618
length(intersect(targets.GRN, targets.RNA)) # very high 5013
length(intersect(intersect(targets.NN,targets.GRN)
                 , targets.RNA)) # very reasonable 3352

# Obtain subset of metadata and RNA-seq data for 24h 
values <- stringr::str_split(metadata$specimenName, "_") %>% 
                  do.call(rbind, .) 

id <- metadata[which(metadata$RNAseq_QCpass == TRUE & metadata$secondLigand == "none") ,]$specimenID 
rawdata_subset <- rawdata[,which(colnames(rawdata) %in% id)]
metadata_subset <- metadata[which(metadata$specimenID %in% id),]

ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

```

We have noticed that they made a gene annotation file available, but there migth be some issues with that. There are also seem a lot of genes. The counts were summed at the gene level, but maybe irrelevant genes. So let's first check how good the conversion is and if we need to adapt it.  
We did get a link for a new annotation package that could help check this.  https://github.com/stephenturner/annotables  
We can annotate more genes and the missing ones don't seem to have a gene symbol.

```{r checking the gene annotation}
# so we have a lot of missing gene symbols and 23 dupblicates in the symbols
sum(is.na(rna.annot$hgnc_symbol))
sum(is.na(rna.annot$ensembl_gene_id))
sum(duplicated(na.omit(rna.annot$hgnc_symbol)))

length(rna.annot$ensembl_gene_id)

sum(is.na(rna.annot$hgnc_symbol)) + sum(duplicated(na.omit(rna.annot$hgnc_symbol))) +
  length(unique(rna.annot$hgnc_symbol)) # one gene too much

# some consistency checks of gene symbols that should be there
"MRC2" %in% rna.annot$hgnc_symbol
"OSBPL7" %in% rna.annot$hgnc_symbol

#new package
# how can we use it? use only protein coding genes
head(grch37)
head(grch38)
colnames(rna.annot) <- c("ensgene", "mdd_annot_symbol")

# based on what we see here, grch38
# annot.37 <- inner_join(annots, grch37)
# length(unique(annot.38$ensgene))
annot.38 <- inner_join(rna.annot, grch38)
length(unique(annot.38$ensgene))
"OSBPL7" %in% annot.38$symbol
"MRC2" %in% annot.38$symbol

sum(is.na(annot.38$ensgene))
sum(is.na(annot.38$mdd_annot_symbol))
sum(is.na(annot.38$symbol))

# we could certainly use the biotype to filter out some of the genes
# for now just check the names
rna.annot <- dplyr::select(annot.38, ensgene, symbol,biotype) %>%
  unique()
```
## Check 3: RNA DE analysis

Now let's focus on one DE analysis for EGF at 24 hours. The sample should pass the QC and the second ligand should be none. We are going to make a general DE model with all relevant ligands we could use and make a contrast for (1) each ligand and (2) each timepoint with respect to PBS at the same timepoint.  

```{r sample selection and design matrix}
# Get unique values of each cytokine, timepoint and replicate
unique_values <- values %>%
                  apply(2, unique) %>%
                  setNames(c("cytokine", "timepoint", "collection", "replicate"))

rawdata_subset$ensgene <- rownames(rawdata_subset) #convert rownames (genes) to a column

# create the subset of samples for the count matrix
# ensure that the gene symbols match with the counts
colnames(rawdata_subset)[ncol(rawdata_subset)] <- colnames(rna.annot)[1]
counts <- dplyr::left_join(rawdata_subset, rna.annot) %>%
  dplyr::select(c(colnames(rna.annot), all_of(id)))
gene.annot <- colnames(counts)[1:2]

# how much is still missing now?
sum(is.na(counts$symbol))
"OSBPL7" %in% counts$symbol
"MRC2" %in% counts$symbol

# what types of genes do we have?
sort(table(counts$biotype), decreasing = T)

# check what are in the empty ones
empty.symbols <- dplyr::filter(counts, symbol == "")
head(empty.symbols$ensgene)
# if we look these up they do not seem to have a regular alias
# either non-coding, pseudogene or novel transcript

# let's throw out the pseudogenes, Nas and empty ones
counts <- dplyr::filter(counts,grepl("pseudogene", 
                                     biotype)==F) %>%
  dplyr::filter((symbol=="")==F) %>%
  na.omit(symbol)

# are there many duplicates? or missing or empty?
length(counts$symbol)
length(unique(counts$symbol)) 
sum(is.na(counts$symbol)) 
dup.check <- as.data.frame(sort(table(counts$symbol),decreasing = T))
head(dup.check, 10)

# maybe throw out the duplicates? not sure about this one, so that's why it is separate
counts <- dplyr::distinct(counts, symbol, .keep_all = T)
dup.check <- as.data.frame(sort(table(counts$symbol),decreasing = T))
head(dup.check)

 # creating the coldata in the DGEList object
time <- metadata_subset$experimentalTimePoint
donor <- metadata_subset$replicate
Treat <- metadata_subset$ligand
Treat <- Treat %>% factor %>% relevel(ref = "PBS")

# create the designmatrix
treatTime <- as.factor(paste0(Treat, "_", time))
table(treatTime) 
group <- treatTime
design <- model.matrix(~ 0 + group + donor, data = metadata_subset)

# taking in to account the repeated measures
colnames(design) <- gsub("group", "", colnames(design))
rownames(design) <- metadata_subset$specimenName

# make the contrasts of interest
colnames(design)
contr <- list()
EGF_24h <- makeContrasts(EGF_24 - PBS_24, levels=design)
HGF_24h <- makeContrasts(HGF_24 - PBS_24, levels=design)
OSM_24h <- makeContrasts(OSM_24 - PBS_24, levels=design)
EGF_48h <- makeContrasts(EGF_48 - PBS_48, levels=design)
HGF_48h <- makeContrasts(HGF_48 - PBS_48, levels=design)
OSM_48h <- makeContrasts(OSM_48 - PBS_48, levels=design)
contr[[1]] <- EGF_24h
contr[[2]] <- HGF_24h
contr[[3]] <- OSM_24h
contr[[4]] <- EGF_48h
contr[[5]] <- HGF_48h
contr[[6]] <- OSM_48h
names(contr) <- c("EGF_24h", "HGF_24h","OSM_24h", "EGF_48h", "HGF_48h","OSM_48h")
```

Now we can run again the generic DE analysis.
```{r DE analysis}
# create the DGE Object because the group influences the downstream filtering
# should contain the relevant conditions with the ligand treatment
# the coldata should cover the relevant variables (treatment,time,donor)
y <- DGEList(counts = counts[,metadata_subset$specimenID], genes = counts[,gene.annot],
                  samples = metadata_subset, group = group)

#### 2. filtering the genes ####
# group is needed for this filtering and it could be kept lower
keep <- filterByExpr(y)
table(keep)
# in at least 3 samples the cpm is larger than 2
# otherwise the gene is too lowly expressed
# keep <- rowSums(cpm(y$counts) > 2) >= 3
# table(keep)
y <- y[keep,]

# by default cpm above 10 in at least 70% of smallest group size
y$samples
rownames(y$samples) <- metadata_subset$specimenName
# background
expr.genes <- unique(y$genes$symbol)

#### 3. Data exploration, looking at the librarysize ####
# an outlier sample can be removed
# library size distribution
# you get a library size per sample and check this
hist(colSums(y$counts)/1e6, breaks=10)
boxplot(colSums(y$counts)/1e6 ~ Treat)
boxplot(colSums(y$counts)/1e6 ~ time)
boxplot(colSums(y$counts)/1e6 ~ donor)
boxplot(colSums(y$counts)/1e6 ~ interaction(Treat, time))
  
# MDS plot
plotMDS(y, labels = group, col = as.numeric(Treat))  

# Preprocess counts, estimate dispersion
y <- calcNormFactors(y)
# What is the effect of the normalization?
plotMDS(cpm(y), labels = group, col = as.numeric(Treat))  
y <- estimateDisp(y, design)
plotBCV(y)
    
# Fit the model
fit <- glmQLFit(y, design, robust = TRUE)
plotQLDisp(fit)
    

de.genes <- list()

for (i in 1:length(contr)){
  print(names(contr)[[i]])
  qlf <- glmQLFTest(fit, contrast=contr[[i]])
  is.de <- decideTestsDGE(qlf,p.value = 0.05, lfc = 1.5)
  print(summary(is.de))
  diffexp <- as.tibble(topTags(qlf, n = Inf, p.value = 1)$table) %>%
      dplyr::select(logFC, FDR, symbol) %>%
      dplyr::rename(lfc = logFC, qval = FDR, gene = symbol) %>%
      na.omit()
  de.genes[[i]] <- list("diffexp" = diffexp,
                          "from" = c(str_sub(names(contr)[i],
                                           start = 1, end = 3)), 
                          "name" = c(names(contr)[i]),
                          "type" = "primary") # we still don´t know what the criterion was for type
  }
names(de.genes) <- names(contr)
  

# sanity check
str(de.genes)
tail(de.genes$EGF_24h$table)
  
DE_EGF_24 <- de.genes$EGF_24h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
DE_EGF_48 <- de.genes$EGF_48h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
DE_OSM_24 <- de.genes$OSM_24h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
DE_OSM_48 <- de.genes$OSM_48h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
DE_HGF_24 <- de.genes$HGF_24h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
DE_HGF_48 <- de.genes$HGF_48h$diffexp  %>% filter((abs(lfc) >= 1.5) & (qval <= 0.05))
```

We see a high amount of DE genes in all contrasts. Right now we take all genes that meet the FDR threshold and no threshold on the logFC. If we check the expressed genes, we ideally have about 10%, so maximum 1600 DE genes and it would help to threshold that further. 
## Check 4: Overlap with the DE genes

We now have potential ground truth data sets that we can use now for the validation of NN. But do the DE genes occur in NN and as relevant target genes in the GRN?

```{r overlap DE genes}
# let's do the overlap with the DE genes for EGF 24, still way too many
targets.DE <- de.genes$EGF_24h$diffexp$gene
length(targets.DE)
length(intersect(targets.NN, targets.DE)) # very high
length(intersect(targets.GRN, targets.DE)) # very high

# what if we are more stringent? who knows ...
```
## Check 5: Run a regular NN validation 

Let's go back to the validation vignette of NN and check how we can do it with appropriate thresholding of the DE.

We see that it is a list, named with the GSEnumber_ligand_add. It contains the from, the name and the type (with primary and secondary). We should ask about that. The diffexp contains lfc, qval (fdr-correction) and gene that have not been filtered. So the function from NicheNet chooses thresholds, in the original case the absolute value of the logFC exceeds 1 and the FDR-corrected p-value is smaller than 0.1. We are making it more stringent to logFC exceeds 1.5 and the FDR-corrected p-value is smaller than 0.05.

```{r NN validation vignette}
# adjust the function to make it more stringent (q<=0.05, abs(lfc)) >= 2
convert_expression_settings_evaluation <- 
  function(setting){
    if (!is.character(setting$from) | !is.character(setting$name)) 
        stop("setting$from and setting$name should be character vectors")
    if (!is.data.frame(setting$diffexp)) 
        stop("setting$diffexp should be data frame")
    if (is.null(setting$diffexp$lfc) | is.null(setting$diffexp$gene) | 
        is.null(setting$diffexp$qval)) 
        stop("setting$diffexp should contain the variables 'lfc', 'qval' and 'diffexp'")
    requireNamespace("dplyr")
    diffexp_df = setting$diffexp %>% mutate(diffexp = (abs(lfc) >= 1.5) & (qval <= 0.05))
    diffexp_vector = diffexp_df$diffexp
    names(diffexp_vector) = diffexp_df$gene
    diffexp_vector = diffexp_vector[unique(names(diffexp_vector))]
    if ((diffexp_vector %>% sum) == 0) {
        print(setting$name)
        warning("No differentially expressed genes, remove this expression dataset")
    }
    return(list(name = setting$name, from = setting$from, response = diffexp_vector))
  }

# The ligand treatment expression datasets used for validation can be downloaded from Zenodo:
expression_settings_validation <- readRDS(url("https://zenodo.org/record/8010790/files/expression_settings"))

str(expression_settings_validation[[1]])
str(de.genes[[1]]) 

# First these validation data sets need to be converted to the right format, makes it in to a logical vector if it is DE or not

settings <- de.genes%>%
  lapply(convert_expression_settings_evaluation)
str(settings[[1]])

# 16431 genes are checked to be expressed or not, so the entire list without filter is needed for validation? 10 more genes than expected 
settings <- settings %>% discard(~length(.$from) > 1) 

# Evaluate transcriptional response prediction on every dataset
performances <- settings %>% lapply(evaluate_target_prediction, ligand_target_matrix) %>% bind_rows()

# Visualize some classification evaluation metrics showing the target gene prediction performance
performances <- performances %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval ,-sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)

scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)",pearson = "Pearson correlation", spearman = "Spearman's rank correlation",mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")

scorerandom <- c(auroc=0.5, aupr_corrected=0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0,mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

performances %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_violin(aes(model, scorevalue, group=model, fill = model)) +
  geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw()

performances %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_boxplot(aes(model, scorevalue, group = model), width = 0.5, outlier.shape = NA) +
  geom_point(aes(model, scorevalue, color = setting), position = position_jitter(width = 0.2), alpha = 0.7) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller = as_labeller(scorelabels)) +
  geom_hline(aes(yintercept = scorevalue), data = scorerandom, linetype = 2, color = "red") +
  theme_bw()

# How good are the ligand activities?
all_ligands <- settings %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
settings_ligand_prediction <- settings %>% convert_settings_ligand_prediction(all_ligands = all_ligands, validation = TRUE)

# infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific datasets (and we do this for all datasets).
ligand_importances <- settings_ligand_prediction %>% lapply(get_single_ligand_importances,ligand_target_matrix) %>% bind_rows()

# Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)

# Replace infinite values with 10000
ligand_importances <- ligand_importances %>% mutate(across(ends_with("log_pval"), ~ifelse(is.infinite(.x), 10000, .x)))

# Get available metrics from the data
exclude_columns <- c("setting", "test_ligand", "ligand")
metrics <- colnames(ligand_importances)[!(colnames(ligand_importances) %in% exclude_columns)]

plots <- lapply(metrics, function(metric) {
  ggplot(ligand_importances, aes(x = setting, y = .data[[metric]])) +
    geom_boxplot() +
    geom_jitter(data = ligand_importances, aes(color = factor(test_ligand)), width = 0.2, alpha = 0.7) +
    labs(title = paste("Metric:", metric),
         x = "Setting",
         y = metric) +
    theme_minimal() +
    scale_color_discrete()  # Add color scale legend
})
plots



evaluation_ligand_prediction <- ligand_importances$setting %>% unique() %>% lapply(function(x){x}) %>%
    lapply(wrapper_evaluate_single_importances_ligand_prediction,ligand_importances) %>%
    bind_rows() %>% inner_join(ligand_importances %>% distinct(setting,ligand))

# Visualize some classification evaluation metrics showing the ligand activity prediction performance
evaluation_ligand_prediction <- evaluation_ligand_prediction %>% dplyr::select(-aupr, -sensitivity_roc, -specificity_roc, -pearson, -spearman, -mean_rank_GST_log_pval) %>% gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)")
scorerandom <- c(auroc=0.5, aupr_corrected=0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

evaluation_ligand_prediction %>%
 filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson", "spearman")) %>%
  ggplot() +
  geom_violin(aes(importance_measure, scorevalue, group=importance_measure, fill = importance_measure)) +
  geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure),width = 0.1) +
  scale_y_continuous("Evaluation ligand activity prediction") +
  scale_x_discrete("Ligand activity measure") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))

performances %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_boxplot(aes(model, scorevalue, group = model), width = 0.5, outlier.shape = NA) +
  geom_point(aes(model, scorevalue, color = setting), position = position_jitter(width = 0.2), size = 4, alpha = 0.7) +
  scale_color_viridis(discrete = TRUE) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free") +  # Using scorename directly
  geom_hline(aes(yintercept = scorevalue), data = scorerandom, linetype = 2, color = "red") +
  theme_bw() +
  theme(
    text = element_text(size = 14),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    plot.title = element_text(size = 18),
    panel.spacing = unit(2, "lines"),
    plot.margin = margin(1, 1, 1, 1, "cm")
  )
```

## Check 6: Run an updated NN validation with the ATAC GRN
Can we boost the performance if we now add the GRN that we have? We will create for each ligand an updated set of RPs that needs to be integrated in the ligand_target_matrix.

##Construction of ligand_target_matrix
First run GRN.R, there the weighted networks and individual ligand-target matrices are constructed. Load here the GRN networks constructed with ANANANSE
In GRN.R are the weighted networks and individual ligand-target-matrices constructed.
```{r ligand-target-matrix construction 1, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_OSM <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_OSM_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")
gr_network_LINCS_HGF <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_HGF_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")
gr_network_LINCS_EGF <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_EGF_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")


targets.GRN_OSM <- unique(gr_network_LINCS_OSM $to)
targets.GRN_EGF <- unique(gr_network_LINCS_EGF $to)
targets.GRN_HGF <- unique(gr_network_LINCS_HGF $to)

length(targets.GRN_OSM)
length(targets.GRN_EGF)
length(targets.GRN_HGF)

length(intersect(targets.NN, targets.GRN_OSM))
length(intersect(targets.NN, targets.GRN_EGF))
length(intersect(targets.NN, targets.GRN_HGF))

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_EGF_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_OSM) %>% bind_rows(gr_network_LINCS_HGF) %>%
  bind_rows(gr_network_LINCS_EGF)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("EGF", "HGF", "OSM")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_3[,"EGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials EGF 24 hour")
png("RP_EGF_24_NO_RNA_Seq.png")
# Create the plot
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_3[,"EGF"],
     xlab = "NicheNet default regulatory potentials",
     ylab = "Regulatory potentials with ATAC",
     main = "Regulatory potentials EGF 24 hour")
# Save and close the PNG device
dev.off()


png("RP_HGF_24_NO_RNA_Seq.png")
plot(ligand_target_matrix[,"HGF"], ligand_target_matrix_ATAC_3[,"HGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials HGF 24 hour")
dev.off()

png("RP_OSM_24_NO_RNA_Seq.png")
plot(ligand_target_matrix[,"OSM"], ligand_target_matrix_ATAC_3[,"OSM"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials OSM 24 hour")
dev.off()
```

```{r ATAC performances 1}
# so some increase, but over the entire spectrum

# Evaluate transcriptional response prediction on every dataset
# shrink the data set for easy use
settings <- settings[-c(2:6)]
performances_ATAC <- settings %>% lapply(evaluate_target_prediction, ligand_target_matrix_total) %>% bind_rows()
# Visualize some classification evaluation metrics showing the target gene prediction performance
performances_ATAC <- performances_ATAC %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval ,-sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)
scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)",pearson = "Pearson correlation", spearman = "Spearman's rank correlation",mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")

scorerandom <- c(auroc=0.5, aupr_corrected=0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0,mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

performances_ATAC %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_violin(aes(model, scorevalue, group=model, fill = model)) +
  geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw()

performances_ATAC %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_boxplot(aes(model, scorevalue, group = model), width = 0.5, outlier.shape = NA) +
  geom_point(aes(model, scorevalue, color = setting), position = position_jitter(width = 0.2), alpha = 0.7) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller = as_labeller(scorelabels)) +
  geom_hline(aes(yintercept = scorevalue), data = scorerandom, linetype = 2, color = "red") +
  theme_bw()


# How good are the ligand activities?
all_ligands_ATAC <- settings %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
settings_ligand_prediction_ATAC <- settings %>% convert_settings_ligand_prediction(all_ligands = all_ligands_ATAC, validation = TRUE)

# infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific datasets (and we do this for all datasets).
ligand_importances_ATAC <- settings_ligand_prediction_ATAC %>% lapply(get_single_ligand_importances, ligand_target_matrix_ATAC_3) %>% bind_rows()

# Get available metrics from the data
exclude_columns <- c("setting", "test_ligand", "ligand")
metrics <- colnames(ligand_importances_ATAC)[!(colnames(ligand_importances_ATAC) %in% exclude_columns)]

plots <- lapply(metrics, function(metric) {
  ggplot(ligand_importances, aes(x = setting, y = .data[[metric]])) +
    geom_boxplot() +
    geom_jitter(data = ligand_importances_ATAC, aes(color = factor(test_ligand)), width = 0.2, alpha = 0.7) +
    labs(title = paste("Metric:", metric),
         x = "Setting",
         y = metric) +
    theme_minimal() +
    scale_color_discrete()  # Add color scale legend
})
plots

# Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)

# Replace infinite values with 10000
ligand_importances <- ligand_importances %>% mutate(across(ends_with("log_pval"), ~ifelse(is.infinite(.x), 10000, .x)))

# Get available metrics from the data
exclude_columns <- c("setting", "test_ligand", "ligand")
metrics <- colnames(ligand_importances)[!(colnames(ligand_importances) %in% exclude_columns)]

plots <- lapply(metrics, function(metric) {
  ggplot(ligand_importances, aes(x = setting, y = .data[[metric]])) +
    geom_boxplot() +
    geom_jitter(data = ligand_importances, aes(color = factor(test_ligand)), width = 0.2, alpha = 0.7) +
    labs(title = paste("Metric:", metric),
         x = "Setting",
         y = metric) +
    theme_minimal() +
    scale_color_discrete()  # Add color scale legend
})
plots

evaluation_ligand_prediction <- ligand_importances$setting %>% unique() %>% lapply(function(x){x}) %>%
    lapply(wrapper_evaluate_single_importances_ligand_prediction,ligand_importances) %>%
    bind_rows() %>% inner_join(ligand_importances %>% distinct(setting,ligand))

# Visualize some classification evaluation metrics showing the ligand activity prediction performance
evaluation_ligand_prediction <- evaluation_ligand_prediction %>% dplyr::select(-aupr, -sensitivity_roc, -specificity_roc, -pearson, -spearman, -mean_rank_GST_log_pval) %>% gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)")
scorerandom <- c(auroc=0.5, aupr_corrected=0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

evaluation_ligand_prediction %>%
 filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson", "spearman")) %>%
  ggplot() +
  geom_violin(aes(importance_measure, scorevalue, group=importance_measure, fill = importance_measure)) +
  geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure),width = 0.1) +
  scale_y_continuous("Evaluation ligand activity prediction") +
  scale_x_discrete("Ligand activity measure") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))
```


```{r ligand-target-matrix construction, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_OSM_RNA <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_OSM_24_grn.txt", header = TRUE, sep = ";")
gr_network_LINCS_HGF_RNA <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_HGF_24_grn.txt", header = TRUE, sep = ";")
gr_network_LINCS_EGF_RNA <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_EGF_24_grn.txt", header = TRUE, sep = ";")

#look into overlap target genes and target genes NicheNet
targets.GRN_OSM_RNA <- unique(gr_network_LINCS_OSM_RNA $to)
targets.GRN_EGF_RNA <- unique(gr_network_LINCS_EGF_RNA$to)
targets.GRN_HGF_RNA <- unique(gr_network_LINCS_HGF_RNA$to)

length(targets.GRN_OSM_RNA)
length(targets.GRN_EGF_RNA)
length(targets.GRN_HGF_RNA)

length(intersect(targets.NN, targets.GRN_OSM_RNA))
length(intersect(targets.NN, targets.GRN_EGF_RNA))
length(intersect(targets.NN, targets.GRN_HGF_RNA))

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total_RNA <- gr_network %>% bind_rows(gr_network_LINCS_OSM_RNA) %>% bind_rows(gr_network_LINCS_HGF_RNA) %>%
  bind_rows(gr_network_LINCS_EGF_RNA)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total_RNA <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total_RNA, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total_RNA <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("EGF", "HGF", "OSM")


ligand_target_matrix_total_RNA <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total_RNA, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))

## plotting regulatory potentials in front of each other

ligand_target_matrix_ATAC_4 <-  subset(ligand_target_matrix_total_RNA, rownames(ligand_target_matrix_total_RNA) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_4[,"EGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials EGF 24 hour")
png("RP_EGF_24_RNA_Seq.png")
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_4[,"EGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials EGF 24 hour")
dev.off()

plot(ligand_target_matrix[,"HGF"], ligand_target_matrix_ATAC_4[,"HGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials HGF 24 hour")

png("RP_HGF_24_RNA_Seq.png")
plot(ligand_target_matrix[,"HGF"], ligand_target_matrix_ATAC_4[,"HGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials HGF 24 hour")
dev.off()


plot(ligand_target_matrix[,"OSM"], ligand_target_matrix_ATAC_4[,"OSM"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials OSM 24 hour")
png("RP_OSM_24_RNA_Seq.png")
plot(ligand_target_matrix[,"OSM"], ligand_target_matrix_ATAC_4[,"OSM"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials OSM 24 hour")
dev.off()

```

```{r ATAC performances}
# so some increase, but over the entire spectrum

# Evaluate transcriptional response prediction on every dataset
# shrink the data set for easy use
settings <- settings[-c(2:6)]
performances_ATAC <- settings %>% lapply(evaluate_target_prediction, ligand_target_matrix_total_RNA) %>% bind_rows()
# Visualize some classification evaluation metrics showing the target gene prediction performance
performances_ATAC <- performances_ATAC %>% dplyr::select(-aupr, -auc_iregulon,-pearson_log_pval,-spearman_log_pval ,-sensitivity_roc, -specificity_roc) %>% gather(key = scorename, value = scorevalue, auroc:spearman)
scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)", auc_iregulon_corrected = "AUC-iRegulon (corrected)",pearson = "Pearson correlation", spearman = "Spearman's rank correlation",mean_rank_GST_log_pval = "Mean-rank gene-set enrichment")

scorerandom <- c(auroc=0.5, aupr_corrected=0, auc_iregulon_corrected = 0, pearson = 0, spearman = 0,mean_rank_GST_log_pval = 0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

performances_ATAC %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_violin(aes(model, scorevalue, group=model, fill = model)) +
  geom_boxplot(aes(model, scorevalue, group = model),width = 0.05) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw()


performances_ATAC %>%
  mutate(model = "NicheNet v2") %>%
  ggplot() +
  geom_boxplot(aes(model, scorevalue, group = model), width = 0.5, outlier.shape = NA) +
  geom_point(aes(model, scorevalue, color = setting), position = position_jitter(width = 0.2), alpha = 0.7) +
  scale_y_continuous("Score target prediction") +
  facet_wrap(~scorename, scales = "free", labeller = as_labeller(scorelabels)) +
  geom_hline(aes(yintercept = scorevalue), data = scorerandom, linetype = 2, color = "red") +
  theme_bw()


# How good are the ligand activities?
all_ligands_ATAC <- settings %>% extract_ligands_from_settings(combination = FALSE) %>% unlist()
settings_ligand_prediction_ATAC <- settings %>% convert_settings_ligand_prediction(all_ligands = all_ligands_ATAC, validation = TRUE)

# infer ligand importances: for all ligands of interest, we assess how well a ligand explains the differential expression in a specific datasets (and we do this for all datasets).
ligand_importances_ATAC <- settings_ligand_prediction_ATAC %>% lapply(get_single_ligand_importances, ligand_target_matrix_ATAC_4) %>% bind_rows()

# Look at predictive performance of single/individual importance measures to predict ligand activity: of all ligands tested, the ligand that is truly active in a dataset should get the highest activity score (i.e. best target gene prediction performance)

# Replace infinite values with 10000
ligand_importances <- ligand_importances_ATAC %>% mutate(across(ends_with("log_pval"), ~ifelse(is.infinite(.x), 10000, .x)))

# Get available metrics from the data
exclude_columns <- c("setting", "test_ligand", "ligand")
metrics <- colnames(ligand_importances_ATAC)[!(colnames(ligand_importances_ATAC) %in% exclude_columns)]

plots <- lapply(metrics, function(metric) {
  ggplot(ligand_importances_ATAC, aes(x = setting, y = .data[[metric]])) +
    geom_boxplot() +
    geom_jitter(data = ligand_importances_ATAC, aes(color = factor(test_ligand)), width = 0.2, alpha = 0.7) +
    labs(title = paste("Metric:", metric),
         x = "Setting",
         y = metric) +
    theme_minimal() +
    scale_color_discrete()  # Add color scale legend
})
plots

evaluation_ligand_prediction <- ligand_importances$setting %>% unique() %>% lapply(function(x){x}) %>%
    lapply(wrapper_evaluate_single_importances_ligand_prediction,ligand_importances) %>%
    bind_rows() %>% inner_join(ligand_importances %>% distinct(setting, ligand))

# Visualize some classification evaluation metrics showing the ligand activity prediction performance
evaluation_ligand_prediction <- evaluation_ligand_prediction %>% dplyr::select (-aupr, -sensitivity_roc, -specificity_roc, -pearson, -spearman, -mean_rank_GST_log_pval) %>% gather(key = scorename, value = scorevalue, auroc:aupr_corrected)
scorelabels <- c(auroc="AUROC", aupr_corrected="AUPR (corrected)")
scorerandom <- c(auroc=0.5, aupr_corrected=0) %>% data.frame(scorevalue=.) %>% rownames_to_column("scorename")

evaluation_ligand_prediction %>%
 filter(importance_measure %in% c("auroc", "aupr_corrected", "mean_rank_GST_log_pval", "auc_iregulon_corrected", "pearson", "spearman")) %>%
  ggplot() +
  geom_violin(aes(importance_measure, scorevalue, group=importance_measure, fill = importance_measure)) +
  geom_boxplot(aes(importance_measure, scorevalue, group = importance_measure),width = 0.1) +
  scale_y_continuous("Evaluation ligand activity prediction") +
  scale_x_discrete("Ligand activity measure") +
  facet_wrap(~scorename, scales = "free", labeller=as_labeller(scorelabels)) +
  geom_hline(aes(yintercept=scorevalue), data=scorerandom, linetype = 2, color = "red") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))
```


```{r ligand-target-matrix construction EGF 1, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_EGF <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_EGF_24_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_EGF_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_EGF)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("EGF")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_3[,"EGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials EGF 24 hour")

```

```{r ligand-target-matrix construction OSM 1, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_OSM <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_OSM_24_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_OSM_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_OSM)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("OSM")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"OSM"], ligand_target_matrix_ATAC_3[,"OSM"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials OSM 24 hour")

```

```{r ligand-target-matrix construction HGF 1, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_HGF <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_HGF_24_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_HGF_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_HGF) 

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("HGF")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"HGF"], ligand_target_matrix_ATAC_3[,"HGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials HGF 24 hour")



```


```{r ligand-target-matrix construction EGF, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_EGF <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_EGF_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_EGF_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_EGF)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("EGF")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"EGF"], ligand_target_matrix_ATAC_3[,"EGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials EGF 24 hour")

```

```{r ligand-target-matrix construction OSM, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_OSM <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_OSM_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_OSM_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_OSM)

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("OSM")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"OSM"], ligand_target_matrix_ATAC_3[,"OSM"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials OSM 24 hour")

```

```{r ligand-target-matrix construction HGF, echo=TRUE}
#import one ligand GRN networks (Ruth generated from https://zenodo.org/record/7418451#.ZGNiqXZBx9O (ANANSE networks))
gr_network_LINCS_OSM <- read.delim2("C:/Users/klara/MaStat/Thesis/GithubThesis/Thesis_NicheNet/Ananse_networks/GRN/LINCS_MCF10A_HGF_24_NO_RNAseq_grn.txt", header = TRUE, sep = ";")

#add your new source to the weighted networks in NicheNet 
new_network_weights_df <- tibble(
  source = "LINCS_MCF10A_HGF_24", 
  avg_weight = 1, 
  median_weight = 1)

new_source_weights_df <- optimized_source_weights_df %>% bind_rows(new_network_weights_df)

#add LINCS GRN to default GRN NicheNet
new_gr_network_total <- gr_network %>% bind_rows(gr_network_LINCS_HGF) 

# aggregate the individual data sources in a weighted manner to obtain a weighted integrated signaling network
weighted_networks_total <- construct_weighted_networks(
  lr_network = lr_network, 
  sig_network = sig_network, 
  gr_network = new_gr_network_total, 
  source_weights_df = new_source_weights_df %>%
    dplyr::select(source, avg_weight) %>%
    rename(weight = avg_weight))

# downweigh the importance of signaling and gene regulatory hubs - use the optimized parameters of this

weighted_networks_total <- apply_hub_corrections(
  weighted_networks = weighted_networks_total,
  lr_sig_hub = hyperparameter_list %>%
    filter(parameter == "lr_sig_hub") %>%
    pull(avg_weight),
  gr_hub = hyperparameter_list %>%
    filter(parameter == "gr_hub") %>%
    pull(avg_weight))

ligands <- list("HGF")


ligand_target_matrix_total <- construct_ligand_target_matrix(
  weighted_networks = weighted_networks_total, 
  ligands = ligands, algorithm = "PPR",
  damping_factor = hyperparameter_list %>% 
    filter(parameter == "damping_factor") %>% 
    pull(avg_weight),
  ltf_cutoff = hyperparameter_list %>% 
    filter(parameter == "ltf_cutoff") %>% 
    pull(avg_weight))


## plotting regulatory potentials in front of each other
ligand_target_matrix_ATAC_3 <-  subset(ligand_target_matrix_total, rownames(ligand_target_matrix_total) %in% rownames(ligand_target_matrix))
plot(ligand_target_matrix[,"HGF"], ligand_target_matrix_ATAC_3[,"HGF"], xlab = "NicheNet default regulatory potentials", ylab = "Regulatory potentials with ATAC", main = "Regulatory potentials HGF 24 hour")

```


